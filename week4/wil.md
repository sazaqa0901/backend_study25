#백엔드 정규 스터디 4주차 과제
<sub>C335282</sub>

레포지토리 계층
-DB와 소통하며 데이터를 조작하는 계층 -서비스 계층이 결정한 비지니스 로직을 실제 DB에 적용
데이터 조작 4가지 기능(JPA가 제공하는 기능)

1. 생성(create)
2. 조회(read)
3. 수정(update)
4. 삭제(delete)

엔티티 매니저
-application.yml정보를 통해 생성
-DB와 직접 소통하는 객체
엔티티 매니저가 하는 일 -새로 생성한 엔티티 객체를 DB에 추가
-DB에서 조회한 데이터로 엔티티 객체 생성성 -엔티티 객체에 대한 수정, 삭제를 DB에 반영

트랜잭션
JPA는 DB와 유사하게 트랜잭션 단위로 동작 -트랜잭션 종료 -> 모든 변경사항을 DB에 반영 -중간에 에러 발생 -> 트랜잭션 범위 안의 모든 변경점을 되돌림(롤백)

영속성 컨텍스트
: DB에서 조회한 엔티티를 캐싱하는 공간 / JPA가 DB에 반영할 엔티티의 모든 변경 사항을 보관하는 공간(버퍼, 기록 저장공간) -엔티티에 대한 변경 사항을 영속성 컨텍스트에 저장 -> 트랜잭션을 커밋 -> 저장된 모든 변경점이 DB에 반영되도록 영속성 컨텍스트를 기반으로 한번에 SQL을 생성

엔티티 저장 -신규 데이터를 만들어서 저장 -스프링 어플리케이션에서 하나의 데이터 = 하나의 엔티티 객체 -엔티티 클래스에 있는 생성자를 통해서 그 클래스의 새로운 객체 생성
엔티티 조회
-find 엔티티 매니저 메서드를 사용
엔티티 수정 -수정할 데이터를 데이터베이스에서 가져옴 -컨텍스트 안에 있는 객체를 수정 시 수정된 정보와 최초 상태를 비교해서 SQL 생성(변경 감지)
엔티티 삭제 -컨텍스트 안에 있는 객체를 삭제 시 엔티티를 삭제 상태로 만듦 -트랜잭션 커밋 또는 flush 호출 시 생성된 쿼리들을 한번에 실행(쓰기지연)
영속성 컨텍스트
따라서 엔티티 매니저는 변경 사항을 모았다가 한번에 SQL을 생성한다. 이때 모든 변경 사항은 영속성 컨텍스트에 저장된다
엔티티 매니저에게 데이터 변경을 요청 -> 하나의 데이터를 나타내는 ‘엔티티 객체’를 영속성 컨텍스트에 올려둠 -> 영속성 컨텍스트에 올려둔 엔티티 객체를 변경

할 일 조회
em.find() -영속성 컨텍스트에서 데이터 조회 -영속성 컨텍스트에 데이터가 없다면 DB에서 읽어옴
em.createQuery() -여러 개의 할 일을 조회할 때는 직접 쿼리를 작성한다.
-JPA에서는 DB에서 사용하는 SQL 대신 객체에 대한 쿼리인 JPQL을 사용(JPQL은 SQL과 문법이 유사) -특정 유저의 할 일 리스트를 조회 -> JPQL where절과 파라미터를 사용하여 작성

SQL vs JPQL
select _
from todo
=> todo는 테이블
select _
from todo as t
where t.user_id
= @user_id

select t
from Todo as t
=> Todo는 엔티티
select t
from Todo as t
where t.user = :user

할 일 수정
수정할 할 일을 조회, 트랜잭션 안에서 객체를 수정 -> 트랜잭션이 끝날 때 엔티티 매니저가 수정 사항을 반영
em.remove() -영속성 컨텍스트에 엔티티를 올려두고 해당 데이터를 삭제 상태로 변경
