#백엔드 정규 스터디 2주차 과제
<sub>C335282 이예영</sub>

##스프링##

- java를 사용하는 백엔드 프레임워크
  = 객체지향 원칙을 지키면서 개발할 수 있도록 도와준다.

##스프링부트## -스프링 프레임워크를 사용하여 개발할 때, 편의를 더해주는 도구 (데이터베이스와 어플리케이션을 연결 설정에 도움, 웹서버 제공) -스프링으로 개발할 때는 스프링 부트를 함께 사용

##스프링 어플리케이션 구조##
---------------스프링부트-------------------
| 내장 tomcat 서버 | --스프링 컨테이너-- |
| | GET /todo/list/| |
| | 전용 컨트롤러 | | DB
| | JSON 컨버터 | |
| ------------------ |

---

**전용 컨트롤러**: API 요청을 처리하는 각각의 메서드
전용컨트롤러는 자바 메서드에 응답하는 형식(자바 객체로 돌려줌)이므로 일반적으로 프론트엔드와 백엔드가 소통하는 방식(JSON)과 맞지 않음. 자바 객체를 JSON형식으로 바꿔줘야함. 이 역할을 **JSON 컨버터**가 함

##스프링 빈(Spring Bean)##

- 어플리케이션 전역에서 사용할 공용 객체, **"하나의 자바 객체"**

공용 창고(스프링 컨테이너)에 빈을 저장해두고 필요한 빈을 컨테이너에서 받아서 사용, 필요한 빈은 스프링 프레임워크가 자동으로 가져다줌. 빈을 요구하는 객체도 스프링 빈(빈이 아닌 객체는 자동으로 가져다주지 않음). 스프링 빈은 서로가 서로를 필요로 하는 구조.

##스프링 컨테이너(=어플리케이션 컨텍스트(Application Context))##

- 스프링 빈이 저장되는 공간 #스프링 컨테이너에 스프링 빈을 저장하는 방법#

1. 설정 파일 작성(수동 등록)
   설정 파일은 자바 클래스로 작성
   클래스에 @Configuration으로 설정 파일임을 명시
   @Configuration, @Bean
2. 컴포넌트 스캔(자동 등록)
   빈으로 등록하려는 클레스에다가 @Component을 붙여 빈으로 등록 가능
   @Component, @ComponentScan

**의존성이란?** 자동차가 움직이려면 바퀴가 필요하다. 즉, 자동차는 바퀴에 의존한다. => A의 기능을 실행하는데 B의 기능이 필요하다면, **'A는 B에 의존한다'**고 한다. ##의존성 주입(Dependency Injection, DI)##

- 내가 의존하는 객체를 직접 생성하지 않고 밖에서 주입 받는 것
- 컨테이너에 저장된 빈과빈 사이의 의의존성을 프레임워크가 주입(빈을 주입할 때, 두 객체 모두 스프링에 의해 관리되어야 하기 때문에 빈이 아닌 객체는 자동으로 주입 불가능) ##의존성을 주입 받는 이유##
- 객체 지향 원칙 중 하나인 OCP(Open Close Principle)원칙을 준수 = 유지보수 용이
- 매번 객체를 생성하는 것이 아니라 생성해둔 객체를 (재)사용하므로 메모리를 효율적으로 사용 ##의존성 주입 방법##
- 주입할 통로(생성자, 필드, 메서드)가 필요
- 이 통로를 통해 주입해 달라고 표시(@Autowired, 생성자가 하나일 경우 생략 가능)
  -> 프레임워크가 알아서 객체 주입

1. 생성자 주입
   의존성이 바뀔 일이 없는 경우 final로 선언
   @RequiredArgsConstructor를 사용해 생성자 추가(생성자 코드 생각 가능)
2. 필드 주입
   필드에서 바로 @Autowired 어노테이션을 사용(final X)
   주로 테스트 코드에서 사용(테스트를 실행할 때 이미 스프링 컨테이너가 존재해야 함)
   클래스에 @SpringBootTest 어노테이션을 사용하면 어플리케이션에 있는 모든 빈을 컨테이너에 등록한 후 테스트 실행
   통합 테스트에도 사용 가능능
   ~3. 세터 주입(메서드 주입)~
   _스프링 빈과 컨테이너를 실제 개발에서는 어떻게 활용할까?_
   스프링 Layered Architecture

- 컨트롤러: 클라이언트의 요청을 받고 응답을 보내는 계층, DTO(Data Transfer Object)를 사용하여 서비스 계층과 데이터를 주고 받음
- 서비스: 어플리케이션의 비지니스 로직이 담기는 계층, 레포지토리 계층과 소통하며 언티티 또는 DTO 사용
- 레포지토리: DB와 소통하며 데이터를 조작하는 계층, 서비스 계층이 결정한 비즈니스 로직을 실제 DB에 적용

#백엔드 정규 스터디 3주차 과제
<sub>C335282 이예영</sub>

어플리케이션이 사용할 DB 설계
JPA를 이용한 DB 구현

스프링 Layered Architecture

DB 설계
문제 상황 -> 프로그램으로 추상화
개체(엔티티/문제 상황을 구성하는 요소)와 그 사이의 관계(개체와 개체 사이의 관계)로 나타낼 수 있음

개체와 관계는 속성(세부적인 특징)을 가질 수 있음
ex. PK(Primary Key) :하나의 개체를 식별할 수 있는 속성

ER Model :개체와 관계로 표한하는 방법 -> 다이어그램으로 표현한 것 :ERD
ex. 개체 -> 테이블 / 관계 -> 테이블 or 외래키 / 속성 -> 테이블 컬럼
ERD Cloud로 ERD를 그릴 수 있음

개체와 개체 사이의 관계 -다대일(N:1) -일대다(1:N) -일대일(1:1) -다대다(N:N)
ex. 1명의 유저는 여러 개의 할 일을 생성 가능, 1개의 할 일은 1명의 유저에 대한 할 일
=> 유저-할 일 = 1:N -> 외래키로 구현

식별관계 :관계 대상의 PK를 자신의 PK로도 사용하는 것
비-식별 관계 : 관계 대상의 PK를 자신의 FK로만 사용하는 것

N:M
회원은 여러 동아리에 소속될 수 있음 => 1:N
동아리는 여러 회원을 가질 수 있음 => 1:M
회원-동아리 = N:M => 쌍(회원PK-동아리PK)을 저장하는 테이블을 만들어 구현
관계는 꼭 서로 다른 엔티티끼리 맺지 않아도 됨(유저-유저 -> 같은 종류의 유저 엔티티끼리 관계를 맺을 수 있음)

JPA(Java Persistence API)
데이터베이스에서 읽어온 데이터를 자바 객체로 매핑하는 자바의 표준 기술(ORM)
엔티티(Entity) :자바와 데이터베이스가 소통하는 단위
테이블의 데이터 하나(레코드)는 엔티티 객체 하나로 매핑됨

엔티티 클래스 정의 -> JPA가 엔티티 클래스 정의를 보고 테이블을 생성하는 SQL을 알아서 작성하고 실행(SQL 작성 시간 줄일 수 있음)

JPA가 데이터베이스와 소통하는 과정
id가 1인 유저 데이터 조회 -> JPA에게 부탁 -> 실제 데이터베이스와 소통할 SQL작성

JPA 설정 파일 작성 -스프링 부트는 기본적으로 H2 in-memory DB를 사용
-DB에 저장된 데이터를 볼 수 있도록 관리자 콘솔을 활성화, 관리자 콘솔에 접속할 url을 명시(명시X -> 매번 랜덤 url 생성)

엔티티클래스
-@Entity 어노테이션으로 이 클래스가 엔티티라는 것을 명시
-@Id 어노테이션으로 PK 필드에 이 필드가 PK라는 것을 명시
-id 값은 보통 데이터를 생성할 때마다 자동으로 1씩 늘어남
-@GeneratedValue를 사용하면 id 값을 자동으로 생성 / 이때 strategy는 IDENTITY로 설정(키 값 결정을 DB에 위임)
-ERD에서 설계했던 Column 이름과 타입을 맞추기 위해
필드에 @Column 으로 이름과 타입을 명시

외래키를 직접 저장한다면? -외래키를 직접 저장 -> 연관된 데이터가 필요할 때 외래키로 데이터를 조회하는 코드를 직접 작성 -엔티티로 저장 -> 테이블을 만들 때 외래키를 만들어줌/ 연관된 데이터가 필요할 때 자동으로 join 쿼리가 실행되고 연관 데이터 얻음

외래키 필드에 지정해야하는 2가지 어노테이션

1. @JoinColumn(FK 컬럼 정보는 명시하는 어노테이션)
2. @ManyToOne @OneToOne @OneToMany @ManyToMany(해당 외래키로 생기는 연관관계 종류를 나타내는 어노테이션)

fetch 속성(연관관계 종류를 나타내는 어노테이션의 속성)
:연결된 엔티티를 언제 가져올지 명시
type
EAGER : 즉시 로딩, Todo 객체 정보를 가져올 때 연결된 User 객체의 모든 정보를 함께 한번에 가져옴
LAZY : 지연 로딩, Todo 객체 정보를 가져올 때 연결된 User 객체의 정보는 필요할 때 가져옴

@NoArgsConstructor : 인자 없는 생성자 생성성(이때 access 속성을 통해 접근 제한자를 protected로 설정)
